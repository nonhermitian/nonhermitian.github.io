<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>nonhermitian.org</id>
  <title>Paul Nation's Blog</title>
  <updated>2021-11-08T00:04:24.127573+00:00</updated>
  <link href="nonhermitian.org"/>
  <link href="nonhermitian.org/blog/atom.xml" rel="self"/>
  <generator uri="https://ablog.readthedocs.org/" version="0.10.20">ABlog</generator>
  <entry>
    <id>nonhermitian.org/posts/2021/2021-10-07-vqe_program.html</id>
    <title>Custom VQE Program for Qiskit Runtime</title>
    <updated>2021-10-07T00:00:00-04:00</updated>
    <content type="html">&lt;p&gt;Here we will demonstrate how to create, upload, and use a custom Program for Qiskit Runtime.  As the utility of the Runtime execution engine lies in its ability to execute many quantum circuits with low latencies, this tutorial will show how to create your own Variational Quantum Eigensolver (VQE) program from scratch.&lt;/p&gt;
&lt;p&gt;You must have Qiskit 0.30+ installed.&lt;/p&gt;
</content>
    <link href="nonhermitian.org/posts/2021/2021-10-07-vqe_program.html" rel="alternate"/>
    <summary>Here we will demonstrate how to create, upload, and use a custom Program for Qiskit Runtime.  As the utility of the Runtime execution engine lies in its ability to execute many quantum circuits with low latencies, this tutorial will show how to create your own Variational Quantum Eigensolver (VQE) program from scratch.You must have Qiskit 0.30+ installed.</summary>
    <category term="Custom" label="Custom"/>
    <published>2021-10-07T00:00:00-04:00</published>
  </entry>
  <entry>
    <id>nonhermitian.org/posts/2021/2021-10-13-expval_program.html</id>
    <title>Custom Expectation Value Program for the Qiskit Runtime</title>
    <updated>2021-10-13T00:00:00-04:00</updated>
    <content type="html">&lt;p&gt;Here we will show how to make a program that takes a circuit, or list of circuits, and computes the expectation values of one or more diagonal operators.&lt;/p&gt;
&lt;p&gt;You must have Qiskit 0.30+ installed.&lt;/p&gt;
</content>
    <link href="nonhermitian.org/posts/2021/2021-10-13-expval_program.html" rel="alternate"/>
    <summary>Here we will show how to make a program that takes a circuit, or list of circuits, and computes the expectation values of one or more diagonal operators.You must have Qiskit 0.30+ installed.</summary>
    <category term="Custom" label="Custom"/>
    <published>2021-10-13T00:00:00-04:00</published>
  </entry>
  <entry>
    <id>nonhermitian.org/posts/2021/2021-10-27-dynamic_BV.html</id>
    <title>Dynamic Bernstein-Vazirani using mid-circuit reset and measurement</title>
    <updated>2021-10-27T00:00:00-04:00</updated>
    <content type="html">&lt;p&gt;The ability to do mid-circuit reset and measurement unlocks a variety of tools for executing quantum circuits.  A brief discussion is given in this &lt;a class="reference external" href="https://www.ibm.com/blogs/research/2021/02/quantum-mid-circuit-measurement/"&gt;IBM Research blog post&lt;/a&gt;.  On particular possibility is the ability to reuse qubits, and in doing so reduce the hardware requirements of some algorithms.  The Bernstein-Vazirani (BV) algorithm is one such example.  In particular, when using phase-kickback, BV usually requires a high degree of qubit connectivity to impliment.  This has been used by trapped-ion hardware vendors to show that their hardware gives better fidelity on these problems, e.g. see (&lt;a class="reference external" href="https://arxiv.org/abs/2102.00371"&gt;https://arxiv.org/abs/2102.00371&lt;/a&gt; and &lt;a class="reference external" href="https://www.nature.com/articles/s41467-019-13534-2"&gt;https://www.nature.com/articles/s41467-019-13534-2&lt;/a&gt;).  However, with reset and measurement, BV requires only two qubits, making connectivity differences mute.  We showed this in a reply Tweet: &lt;a class="reference external" href="https://twitter.com/nonhermitian/status/1362348935440986113"&gt;https://twitter.com/nonhermitian/status/1362348935440986113&lt;/a&gt;, but did not explain how we got that figure.  So here is how I did it.&lt;/p&gt;
&lt;p&gt;Here we select the backend and extract its two-qubit gate coupling map.  This is not the same backend used in the original figure as, at the time or writing, that one is offline.  It is however the same processor family and revision.&lt;/p&gt;
</content>
    <link href="nonhermitian.org/posts/2021/2021-10-27-dynamic_BV.html" rel="alternate"/>
    <summary>The ability to do mid-circuit reset and measurement unlocks a variety of tools for executing quantum circuits.  A brief discussion is given in this IBM Research blog post.  On particular possibility is the ability to reuse qubits, and in doing so reduce the hardware requirements of some algorithms.  The Bernstein-Vazirani (BV) algorithm is one such example.  In particular, when using phase-kickback, BV usually requires a high degree of qubit connectivity to impliment.  This has been used by trapped-ion hardware vendors to show that their hardware gives better fidelity on these problems, e.g. see (https://arxiv.org/abs/2102.00371 and https://www.nature.com/articles/s41467-019-13534-2).  However, with reset and measurement, BV requires only two qubits, making connectivity differences mute.  We showed this in a reply Tweet: https://twitter.com/nonhermitian/status/1362348935440986113, but did not explain how we got that figure.  So here is how I did it.Here we select the backend and extract its two-qubit gate coupling map.  This is not the same backend used in the original figure as, at the time or writing, that one is offline.  It is however the same processor family and revision.</summary>
    <category term="Dynamic" label="Dynamic"/>
    <published>2021-10-27T00:00:00-04:00</published>
  </entry>
  <entry>
    <id>nonhermitian.org/posts/2021/2021-10-31-best_swap_mapper_qiskit.html</id>
    <title>Choosing the best Qiskit swap mapper</title>
    <updated>2021-10-31T00:00:00-04:00</updated>
    <content type="html">&lt;p&gt;One of the most important (perhaps the most important) steps when compiling quantum circuits for architectures with limited connectivity is swap mapping.  If a requested two-qubit gate cannot be implimented directly on hardware, the states of the corresponding qubits must be swapped with those of their neighboors until the states reside on qubits where a two qubit gate is supported.  Swap gates are expensive, equal to three CNOT gates, and therefore moving qubit states around using the fewest number of swap gates is desireable.  Unfortunately, directly computing the minimum number of swap gates is NP-complete, and heuristics need to be developed that come close to the ideal solution while scaling favorably with the number of qubits.&lt;/p&gt;
&lt;p&gt;Qiskit supports a variety of swap mappers and other optimization settings, and how to best set these options is important for getting high-fidelty results.  Additionally, there are other Qiskit compatible compilers out there that should also be evaluated.  To this end, here we look at a selection of circuits compiled with various Qiskit compiler settings, as well as those produced with the &lt;a class="reference external" href="https://cambridgequantum.com/home/"&gt;Cambridge Quantum Computing (CQC)&lt;/a&gt; &lt;a class="reference external" href="https://github.com/CQCL/tket"&gt;Tket compiler&lt;/a&gt;.  We will investigate the performance of these methods in terms of both number of CNOT gates in the output, as well as the associated runtimes.  Because Qiskit swap mappers are stochastic, we will run each one several times and plot the distributions of results.&lt;/p&gt;
</content>
    <link href="nonhermitian.org/posts/2021/2021-10-31-best_swap_mapper_qiskit.html" rel="alternate"/>
    <summary>One of the most important (perhaps the most important) steps when compiling quantum circuits for architectures with limited connectivity is swap mapping.  If a requested two-qubit gate cannot be implimented directly on hardware, the states of the corresponding qubits must be swapped with those of their neighboors until the states reside on qubits where a two qubit gate is supported.  Swap gates are expensive, equal to three CNOT gates, and therefore moving qubit states around using the fewest number of swap gates is desireable.  Unfortunately, directly computing the minimum number of swap gates is NP-complete, and heuristics need to be developed that come close to the ideal solution while scaling favorably with the number of qubits.Qiskit supports a variety of swap mappers and other optimization settings, and how to best set these options is important for getting high-fidelty results.  Additionally, there are other Qiskit compatible compilers out there that should also be evaluated.  To this end, here we look at a selection of circuits compiled with various Qiskit compiler settings, as well as those produced with the Cambridge Quantum Computing (CQC) Tket compiler.  We will investigate the performance of these methods in terms of both number of CNOT gates in the output, as well as the associated runtimes.  Because Qiskit swap mappers are stochastic, we will run each one several times and plot the distributions of results.</summary>
    <category term="bestpractices" label="best practices"/>
    <published>2021-10-31T00:00:00-04:00</published>
  </entry>
  <entry>
    <id>nonhermitian.org/posts/2021/2021-11-07-rep_delay.html</id>
    <title>Improving state prep errors on IBM Quantum systems</title>
    <updated>2021-11-07T00:00:00-04:00</updated>
    <content type="html">&lt;p&gt;It is often taken for granted that qubits are initialized to zero when executing quantum circuits on hardware.  However, errors in the reset process mean that this initialization is not perfect leading to state preparation errors.  Here we will look at state prep errors and how to improve them on IBM Quantum systems.&lt;/p&gt;
&lt;p&gt;Here we will use two lesser known configuration variables available on IBM Quantum systems to do so.  First is &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;rep_delay&lt;/span&gt;&lt;/code&gt;.  This is the delay time before the next circuit is executed.  Each backend has a different &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;default_rep_delay&lt;/span&gt;&lt;/code&gt; (although as of the time of writing many are &lt;span class="math notranslate nohighlight"&gt;\(250~\mu \rm s\)&lt;/span&gt; or lower) and support tuning this parameter from &lt;span class="math notranslate nohighlight"&gt;\(0\)&lt;/span&gt; up to &lt;span class="math notranslate nohighlight"&gt;\(500~\mu \rm s\)&lt;/span&gt;.  Why in the world would I want to vary this parameter?  Well if I set &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;rep_delay=0&lt;/span&gt;&lt;/code&gt; then I can get much faster throughput as the default delay is nominally longer than the &lt;span class="math notranslate nohighlight"&gt;\(T_{1}\)&lt;/span&gt; time of the system.  However when doing so you are trusting the implicit reset (called “unconditional reset”) to do its job and reset the qubits to their ground state with high-fidelity.  Failure to do so would lead to state-prep errors that propagate through the circuit.  This is why the delay is usually longer than &lt;span class="math notranslate nohighlight"&gt;\(T_{1}\)&lt;/span&gt;; let the enviornment help your reset fidelity.  Second is &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;init_qubits&lt;/span&gt;&lt;/code&gt; that tells the hardware to not perform an unconditional reset.  As no reset at all would quickly lead to junk, this setting needs to be done in concert with &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;reset&lt;/span&gt;&lt;/code&gt; instructions being added to the beginning of your circuits.  Perhaps this is better, or maybe a single reset at the beginning and the uncondtional reset.  Lets find out.&lt;/p&gt;
</content>
    <link href="nonhermitian.org/posts/2021/2021-11-07-rep_delay.html" rel="alternate"/>
    <summary>It is often taken for granted that qubits are initialized to zero when executing quantum circuits on hardware.  However, errors in the reset process mean that this initialization is not perfect leading to state preparation errors.  Here we will look at state prep errors and how to improve them on IBM Quantum systems.Here we will use two lesser known configuration variables available on IBM Quantum systems to do so.  First is rep_delay.  This is the delay time before the next circuit is executed.  Each backend has a different default_rep_delay (although as of the time of writing many are 250~\mu \rm s or lower) and support tuning this parameter from 0 up to 500~\mu \rm s.  Why in the world would I want to vary this parameter?  Well if I set rep_delay=0 then I can get much faster throughput as the default delay is nominally longer than the T_{1} time of the system.  However when doing so you are trusting the implicit reset (called “unconditional reset”) to do its job and reset the qubits to their ground state with high-fidelity.  Failure to do so would lead to state-prep errors that propagate through the circuit.  This is why the delay is usually longer than T_{1}; let the enviornment help your reset fidelity.  Second is init_qubits that tells the hardware to not perform an unconditional reset.  As no reset at all would quickly lead to junk, this setting needs to be done in concert with reset instructions being added to the beginning of your circuits.  Perhaps this is better, or maybe a single reset at the beginning and the uncondtional reset.  Lets find out.</summary>
    <category term="SPAM" label="SPAM"/>
    <category term="Reset" label="Reset"/>
    <category term="Dynamic" label="Dynamic"/>
    <published>2021-11-07T00:00:00-04:00</published>
  </entry>
</feed>
